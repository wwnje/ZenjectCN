# 对象图验证 Object Graph Validation

**概观**

使用DI框架设置绑定时的常用工作流程如下：

* 在代码中添加一些绑定
* 执行你的应用程序
* 观察一堆与DI相关的异常
* 修改绑定以解决问题
* 重复

这适用于小型项目，但随着项目复杂性的增加，这通常是一个单调乏味的过程。 如果应用程序的启动时间特别糟糕，或者异常仅发生在运行时各个点的工厂，则问题会变得更严重。 那有没有很好的工具可以来分析您的对象图(object graph )并告诉您所有缺少的绑定的确切位置，并且无需启动整个应用程序。

您可以通过执行菜单项`Edit -> Zenject -> Validate Current Scene`，或者只需按下要验证的场景打开`CTRL+ALT+V`，即可在Zenject中开箱即用。 这将执行当前场景的所有安装程序，结果是完全绑定的容器。 然后，它将遍历对象图并验证是否可以找到所有绑定（而不实际实例化任何绑定）。 换句话说，它执行正常启动过程的'dry run'。 在引擎盖(hood)下，这可以通过在容器中存储虚拟对象来代替实际实例化类来实现。

或者，您可以执行菜单项`Edit -> Zenject -> Validate Then Run`然后运行或只需按`CTRL+SHIFT+R`. 这将验证您打开的场景，然后如果验证成功，它将开始播放模式。 验证通常非常快，所以这可能是一个很好的选择，特别是如果你的游戏有一个昂贵的启动时间。

请注意，这还将包括工厂和内存池(factories and memory pools)，这尤其有用，因为这些错误可能在启动后的某个时间才会被捕获。

有几点需要注意：

* 没有执行实际的逻辑代码 - 只调用安装绑定。 这意味着如果除了绑定命令之外的安装程序中有逻辑，那么这些逻辑也会执行，并且在运行验证时可能会导致问题（如果该逻辑要求容器返回实际值）

* 将**null**值注入实际实例化的依赖项中，例如安装程序（绑定内容的关键字）

您可能希望在验证模式下注入一些类。 在这种情况下，您可以使用`[ZenjectAllowDuringValidation]`标记它们。

另请注意，某些验证行为可在[zenjectsettings](zenjectsettings.md)中配置

**自定义验证**

如果要添加自己的验证逻辑，只需将其中一个类继承自`IValidatable`即可。 执行此操作后，只要您的类在某个安装程序中绑定，它将在验证期间实例化，然后将调用其 `Validate()`方法。 但请注意，它所具有的任何依赖项将被注入为null（除非标记为`[ZenjectAllowDuringValidation]`属性）。

如果您希望验证失败，您可以在Validate方法内部抛出异常，或者只是将信息记录到控制台。 自定义validatable中出现的一个常见问题是实例化无法验证的类型。 通过在验证期间实例化它们，它将确保可以解决所有依赖关系。

例如，如果您创建一个使用`Container.Instantiate<Foo>()`直接实例化类型的自定义工厂，则不会验证 `Foo` ，因此在运行时之前您不会发现它是否缺少某些依赖项。 但是，您可以通过让工厂实现 `IValidatable`然后在`Validate()`方法中调用`Container.Instantiate<Foo>()`来解决此问题。